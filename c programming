char **stringMatching(char **words, int wordsSize, int *returnSize)
{
  char **ans = (char **)calloc(wordsSize, sizeof(char *));
  int ansSize = 0;

  for (int i = 0; i < wordsSize; i++)
  {
    for (int j = 0; j < wordsSize; j++)
    {
      if (j == i)
        continue;
      if (strstr(words[j], words[i]))
      {
        ans[ansSize++] = words[i];
        break;
      }
    }
  }

  (*returnSize) = ansSize;
  return ans;
}


#define MAX_SIZE 100

int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

// Function to check if the given coordinates are within the grid boundaries
int isValid(int x, int y, int m, int n) {
    return (x >= 0 && x < m && y >= 0 && y < n);
}

// Depth-first search to mark all cells in the same island
void dfs(int** grid, int** visited, int x, int y, int m, int n) {
    visited[x][y] = 1;
    for (int i = 0; i < 4; i++) {
        int nx = x + dir[i][0];
        int ny = y + dir[i][1];
        if (isValid(nx, ny, m, n) && grid[nx][ny] == 1 && !visited[nx][ny]) {
            dfs(grid, visited, nx, ny, m, n);
        }
    }
}

// Function to count the number of islands in the grid
int countIslands(int** grid, int m, int n) {
    int** visited = (int**)malloc(m * sizeof(int*));
    for (int i = 0; i < m; i++) {
        visited[i] = (int*)malloc(n * sizeof(int));
        memset(visited[i], 0, n * sizeof(int));
    }
    int count = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1 && !visited[i][j]) {
                count++;
                dfs(grid, visited, i, j, m, n);
            }
        }
    }
    for (int i = 0; i < m; i++) {
        free(visited[i]);
    }
    free(visited);
    return count;
}

// Main function to return the minimum number of days to disconnect the grid
int minDays(int** grid, int gridSize, int* gridColSize) {
    int m = gridSize;
    int n = gridColSize[0];

    if (countIslands(grid, m, n) != 1) {
        return 0;
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                grid[i][j] = 0;
                if (countIslands(grid, m, n) != 1) {
                    grid[i][j] = 1; // Restore the grid before returning
                    return 1;
                }
                grid[i][j] = 1; // Restore the grid
            }
        }
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                grid[i][j] = 0;
                for (int k = 0; k < m; k++) {
                    for (int l = 0; l < n; l++) {
                        if (grid[k][l] == 1) {
                            grid[k][l] = 0;
                            if (countIslands(grid, m, n) != 1) {
                                grid[k][l] = 1; // Restore the grid before returning
                                grid[i][j] = 1; // Restore the grid before returning
                                return 2;
                            }
                            grid[k][l] = 1; // Restore the grid
                        }
                    }
                }
                grid[i][j] = 1; // Restore the grid
            }
        }
    }

    return 3;
}


typedef struct {
    int k;
    int *nums;
    int numsSize;
} KthLargest;

int compare(const void * a, const void * b) {
    return ( *(int*)b - *(int*)a );
}

KthLargest* kthLargestCreate(int k, int* nums, int numsSize) {
   KthLargest *box=malloc(sizeof(KthLargest));
   box->k=k;
   box->numsSize=numsSize;
   box->nums=malloc(sizeof(int)*numsSize);
   for(int i = 0; i < numsSize; i++) {
    box->nums[i] = nums[i];
    }
    qsort(box->nums, box->numsSize, sizeof(int), compare);
    return box;
}

int kthLargestAdd(KthLargest* obj, int val) {
   
    obj->nums = realloc(obj->nums, (obj->k+1) * sizeof(int));
    int i;
    for (i = obj->k - 1; i >= 0; i--) {
        if (obj->nums[i] < val) {
            obj->nums[i + 1] = obj->nums[i]; 
            } 
            else {
            break;
        }
    }

    obj->nums[i + 1] = val;
    return  obj->nums[obj->k-1] ;
    
}

void kthLargestFree(KthLargest* obj) {
    free(obj);
}

int cmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }

void backtrack(int *nums, int numsSize, int *curr, int curidx, int remainingSum, int **res,
               int *returnSize, int **returnColumnSize, int idx) {
    if (remainingSum < 0) {
        return;
    } else if (remainingSum == 0) {
        res[(*returnSize)] = (int *)malloc(curidx * sizeof(int));
        for (int i = 0; i < curidx; i++) {
            res[(*returnSize)][i] = curr[i];
        }
        (*returnColumnSize)[(*returnSize)] = curidx;
        (*returnSize)++;
        return;
    }
    for (int i = idx; i < numsSize; i++) {
        if (i > idx && nums[i] == nums[i - 1]) continue;
        curr[curidx++] = nums[i];
        backtrack(nums, numsSize, curr, curidx, remainingSum - nums[i], res, returnSize,
                  returnColumnSize, i + 1);
        curidx--;
    }
}

int **combinationSum2(int *candidates, int candidatesSize, int target, int *returnSize,
                      int **returnColumnSizes) {
    *returnSize = 0;
    int **res = (int **)malloc(1024 * sizeof(int));
    *returnColumnSizes = (int *)malloc(1024 * sizeof(int));
    qsort(candidates, candidatesSize, sizeof(int), cmp);
    int *curr = (int *)malloc(128 * sizeof(int));
    backtrack(candidates, candidatesSize, curr, 0, target, res, returnSize, returnColumnSizes, 0);
    return res;
}


bool lemonadeChange(int* bills, int billsSize) {
    for(int i = 0, five = 0, ten = 0; i < billsSize; i++){
        switch(bills[i]){
            case 5: five++; break;
            case 10:
                if(five) five--, ten++;
                else return 0;
                break;
            case 20:
                if(ten && five) ten--, five--;
                else if(five > 2) five -= 3;
                else return 0;
                break;
        }
    }

    return 1;
}

int maxDistance(int** arrays, int arraysSize, int* arraysColSize){
    int minVal = arrays[0][0];
    int maxVal = arrays[0][arraysColSize[0] - 1];
    int maxDistance = 0;

    for (int i = 1; i < arraysSize; i++) {
        int currentMin = arrays[i][0];
        int currentMax = arrays[i][arraysColSize[i] - 1];

        if (abs(currentMax - minVal) > maxDistance)
            maxDistance = abs(currentMax - minVal);
        if (abs(maxVal - currentMin) > maxDistance)
            maxDistance = abs(maxVal - currentMin);

        if (currentMin < minVal)
            minVal = currentMin;
        if (currentMax > maxVal)
            maxVal = currentMax;
    }

    return maxDistance;
}

long long maxPoints(int** points, int pointsSize, int* pointsColSize) {
    int rows = pointsSize;
    int cols = pointsColSize[0];
    
    long long *previousRow = (long long*)malloc(sizeof(long long) * cols);
    long long *currentRow = (long long*)malloc(sizeof(long long) * cols);

    for (int col = 0; col < cols; ++col) {
        previousRow[col] = points[0][col];
    }

    for (int row = 1; row < rows; ++row) {
        long long *leftMax = (long long*)malloc(sizeof(long long) * cols);
        long long *rightMax = (long long*)malloc(sizeof(long long) * cols);

        leftMax[0] = previousRow[0];
        for (int col = 1; col < cols; ++col) {
            leftMax[col] = (leftMax[col - 1] > previousRow[col] + 1) ? leftMax[col - 1] - 1 : previousRow[col];
        }

        rightMax[cols - 1] = previousRow[cols - 1];
        for (int col = cols - 2; col >= 0; --col) {
            rightMax[col] = (rightMax[col + 1] > previousRow[col] + 1) ? rightMax[col + 1] - 1 : previousRow[col];
        }

        for (int col = 0; col < cols; ++col) {
            currentRow[col] = points[row][col] + (leftMax[col] > rightMax[col] ? leftMax[col] : rightMax[col]);
        }

        free(leftMax);
        free(rightMax);

        long long *temp = previousRow;
        previousRow = currentRow;
        currentRow = temp;
    }

    long long maxPoints = LLONG_MIN;
    for (int col = 0; col < cols; ++col) {
        if (previousRow[col] > maxPoints) {
            maxPoints = previousRow[col];
        }
    }

    free(previousRow);
    free(currentRow);

    return maxPoints;
}

int nthUglyNumber(int n) {
    int ugly[n]; 
    ugly[0] = 1;
    
    int i2 = 0, i3 = 0, i5 = 0;
    
    for (int i = 1; i < n; i++) {
        int next2 = ugly[i2] * 2;
        int next3 = ugly[i3] * 3;
        int next5 = ugly[i5] * 5;
        
        int next_ugly = (next2 < next3) ? 
                        ((next2 < next5) ? next2 : next5) : 
                        ((next3 < next5) ? next3 : next5);
        
        ugly[i] = next_ugly;
        
        if (next_ugly == next2) i2++;
        if (next_ugly == next3) i3++;
        if (next_ugly == next5) i5++;
    }
    
    return ugly[n-1];
}

//C Code
int stoneGameRC(int n, int *rightSum, int i, int m, int dp[n][n]) {
    int x, j, ans, maxAns = 0;
    if (i == n)
        return 0;
    if (i + 2 * m >= n)
        return rightSum[i];
    if (dp[i][m])
        return dp[i][m];
    for (j = 1; j <= 2 * m; ++j) {
        if (j < m)
            x = m;
        else
            x = j;
        ans = rightSum[i] - stoneGameRC(n, rightSum, i + j, x, dp);
        if (ans > maxAns)
            maxAns = ans;
    }
    return dp[i][m] = maxAns;
}

int stoneGameII(int* piles, int pilesSize) {
    int i, n = pilesSize, rightSum[n], dp[n][n];
    memset(dp, 0, sizeof(dp));
    rightSum[n - 1] = piles[n - 1];
    for (i = n - 2; i >= 0; --i) {
        rightSum[i] = piles[i] + rightSum[i + 1];
    }
    return stoneGameRC(n, rightSum, 0, 1, dp);
}

int strangePrinter(const char* s);
int Util(int i, int j, const char* s, int** dp);
int strangePrinter(const char* s) {
    int n = strlen(s);
    int** dp = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        dp[i] = (int*)malloc(n * sizeof(int));
        for (int j = 0; j < n; j++) {
            dp[i][j] = -1;
        }
    }
    int result = Util(0, n - 1, s, dp);
    for (int i = 0; i < n; i++) {
        free(dp[i]);
    }
    free(dp);

    return result;
}
int Util(int i, int j, const char* s, int** dp) {
    if (i > j) {
        return 0;
    }
    if (dp[i][j] != -1) {
        return dp[i][j];
    }
    char firstLetter = s[i];
    int answer = 1 + Util(i + 1, j, s, dp);
    for (int k = i + 1; k <= j; k++) {
        if (s[k] == firstLetter) {
            int betterAnswer = Util(i, k - 1, s, dp) + Util(k + 1, j, s, dp);
            if (betterAnswer < answer) {
                answer = betterAnswer;
            }
        }
    }
    dp[i][j] = answer;
    return answer;
}

#define ABS(a) ((a < 0) ? (-a) : (a))
    
int GCD(int a, int b) {
    while ((a % b) > 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return b;
}

bool Isdigit(char c) {
    if (c >= '0' && c <= '9') return true;
    return false;
}

int process_numerator(char* e, int e_len, int idx, int* arr, int* arr_idx) {
    int tmp = 0;
    bool IsNegative = false;
    while (idx < e_len && e[idx] != '/') {
        if (e[idx] == '-') {
            IsNegative = true;
        } else if (Isdigit(e[idx]) == true) {
            tmp *= 10;
            tmp += (e[idx] - '0');
        }
        idx++;
    }
    if (IsNegative == true) tmp *= (-1);
    if (tmp != 0) arr[(*arr_idx)] = tmp;
    return idx;
}

int process_denominator(char* e, int e_len, int idx, int* arr, int* arr_idx) {
    int tmp = 0;
    while (idx < e_len && (Isdigit(e[idx]) == true)) {
        tmp *= 10;
        tmp += (e[idx] - '0');
        idx++;
    }
    if (tmp != 0) arr[(*arr_idx)++] = tmp;
    return idx;
}

char* fractionAddition(char* expression) {
    int n = strlen(expression), arr_idx = 0;
    int* num_arr = (int*) calloc(n, sizeof(int));
    int* den_arr = (int*) calloc(n, sizeof(int));
    for (int i = 0; i < n; i++) {
        i = process_numerator(expression, n, i, num_arr, &arr_idx) + 1;
        i = process_denominator(expression, n, i, den_arr, &arr_idx) - 1;
    }
    
    int a = 0, d = den_arr[0];
    for (int i = 1; i < arr_idx; i++) {
        d *= den_arr[i];
    }
    for (int i = 0; i < arr_idx; i++) {
        a += ((d / den_arr[i]) * num_arr[i]);
    }
    if (a == 0) {
        free(num_arr);
        free(den_arr);
        return "0/1";
    }
    
    int g = GCD(ABS(a), d);
    a /= g;
    d /= g;
    char* ans = (char*) calloc(n+1, sizeof(char));
    sprintf(ans, "%d/%d", a, d);
    free(num_arr);
    free(den_arr);
    return ans;
}

#define maxN 200

void post(struct TreeNode* root, int* arr, int* idx) {
    if (root == NULL) {
        return;
    }
    post(root->left, arr, idx);
    post(root->right, arr, idx);
    arr[(*idx)++] = root->val;
}

int* postorderTraversal(struct TreeNode* root, int* returnSize) {
    int* arr = (int*)malloc(maxN * sizeof(int));
    int idx = 0;
    post(root, arr, &idx);
    *returnSize = idx;
    return arr;
}

void postordertravel(struct Node* root, int* returnSize,int*v){
    if(root == NULL){
        return;
    }
    for(int i=0;i<root->numChildren;i++){
        postordertravel(root->children[i], returnSize,v);
    }
    v[(*returnSize)++]=root->val;

}

int* postorder(struct Node* root, int* returnSize) {
    *returnSize=0;
    int *v=(int*)malloc(sizeof(int)*10000);
    postordertravel(root, returnSize,v);
    return v;
}

bool scanIsland(int** grid1, int** grid2, short row, short col, short n, short m){
    grid2[row][col] = 2;
    bool subIsland = 1;

    if(row > 0 && grid2[row - 1][col] == 1)
        subIsland &= grid1[row - 1][col] ? scanIsland(grid1, grid2, row - 1, col, n, m) : 0;

    if(col > 0 && grid2[row][col - 1] == 1)
        subIsland &= grid1[row][col - 1] ? scanIsland(grid1, grid2, row, col - 1, n, m) : 0;

    if(row < n - 1 && grid2[row + 1][col] == 1)
        subIsland &= grid1[row + 1][col] ? scanIsland(grid1, grid2, row + 1, col, n, m) : 0;

    if(col < m - 1 && grid2[row][col + 1] == 1)
        subIsland &= grid1[row][col + 1] ? scanIsland(grid1, grid2, row, col + 1, n, m) : 0;

    return subIsland;
}

int countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize) {
    short i, j, n = grid1Size, m = grid1ColSize[0], res = 0;

    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            if(grid1[i][j] && grid2[i][j] == 1)
                res += scanIsland(grid1, grid2, i, j, n, m);

    return res;
}

#define vector(ptr, type, size) \
    (ptr = malloc(size * sizeof(type))) 

#define swap(a,b) \
    do {          \
        __typeof(a) temp = (a); \
        a = (b);  \
        b = temp; \
    } while(0)

int findPar(int a, int *pair)
{
    if(pair[a] == a) 
        return a;
    return pair[a] = findPar(pair[a], pair);
}

void merge(int a, int b, int *pair, int *bePairCounts)
{
    a = findPar(a, pair);
    b = findPar(b, pair);

    if (a != b) {
        if(bePairCounts[a] < bePairCounts[b]) 
            swap(a,b);
        pair[b] = a;
        bePairCounts[a] += bePairCounts[b];
    }
}

int removeStones(int **stones, int stonesSize, int *stonesColSize)
{
    int ans = 0;
    int *pair, *bePairCounts;
    vector(pair, int, stonesSize);
    vector(bePairCounts, int, stonesSize);

    // init. pair: self trace self
    for(int i = 0; i < stonesSize; i++) 
        pair[i] = i;
    
    // init. bePairCounts = {[...] = 1}
    for(int i = 0; i < stonesSize; i++) 
        bePairCounts[i] = 1;
    
    int row_seen[10001] = {[0 ... 10000] = -1}, \
        col_seen[10001] = {[0 ... 10000] = -1};

    for (int i = 0; i < stonesSize; i++) {
        if(row_seen[stones[i][0]] != -1)
            merge(row_seen[stones[i][0]], i, pair, bePairCounts);
        else 
            row_seen[stones[i][0]] = i;

        if(col_seen[stones[i][1]] != -1)
            merge(col_seen[stones[i][1]], i, pair, bePairCounts);
        else 
            col_seen[stones[i][1]] = i;
    }

    for(int i = 0; i < stonesSize; i++)
        if(pair[i] == i) 
            ans += (bePairCounts[i] - 1);

    return ans;
}

#define maxN 10005
#define maxCapa 10

typedef struct {
    int node;
    double prob;
} Edge;

typedef struct {
    Edge *edges;
    int size;
    int capacity;
} AdjList;

typedef struct {
    double probability;
    int node;
} QueueNode;

typedef struct {
    QueueNode *nodes;
    int idx;
    int capacity;
} MaxHeap;

void swap(QueueNode *a, QueueNode *b) {
    QueueNode tmp = *a;
    *a = *b;
    *b = tmp;
}

void heapify(MaxHeap *heap, int index) {
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int biggeridx = index;
    if (left < heap->idx && heap->nodes[left].probability > heap->nodes[biggeridx].probability) {
        biggeridx = left;
    }
    if (right < heap->idx && heap->nodes[right].probability > heap->nodes[biggeridx].probability) {
        biggeridx = right;
    }
    if (biggeridx != index) {
        swap(&heap->nodes[index], &heap->nodes[biggeridx]);
        heapify(heap, biggeridx);
    }
}

QueueNode pop(MaxHeap *heap) {
    QueueNode res = heap->nodes[0];
    heap->nodes[0] = heap->nodes[heap->idx - 1];
    heap->idx--;
    heapify(heap, 0);
    return res;
}

void push(MaxHeap *heap, double probability, int node) {
    if (heap->idx == heap->capacity) {
        heap->capacity *= 2;
        heap->nodes = (QueueNode *)realloc(heap->nodes, heap->capacity * sizeof(QueueNode));
    }
    heap->nodes[heap->idx].probability = probability;
    heap->nodes[heap->idx].node = node;
    heap->idx++;
    int index = heap->idx - 1;
    while (index > 0 && heap->nodes[index].probability > heap->nodes[(index - 1) / 2].probability) {
        swap(&heap->nodes[index], &heap->nodes[(index - 1) / 2]);
        index = (index - 1) / 2;
    }
}

AdjList *create(int n) {
    AdjList *adj = (AdjList *)malloc(n * sizeof(AdjList));
    for (int i = 0; i < n; i++) {
        adj[i].edges = (Edge *)malloc(maxCapa * sizeof(Edge));
        adj[i].size = 0;
        adj[i].capacity = maxCapa;
    }
    return adj;
}

void addEdge(AdjList *adj, int u, int v, double prob) {
    if (adj[u].size == adj[u].capacity) {
        adj[u].capacity *= 2;
        adj[u].edges = (Edge *)realloc(adj[u].edges, adj[u].capacity * sizeof(Edge));
    }
    adj[u].edges[adj[u].size].node = v;
    adj[u].edges[adj[u].size].prob = prob;
    adj[u].size++;
}

double maxProbability(int n, int **edges, int edgesSize, int *edgesColSize, double *succProb,
                      int succProbSize, int start, int end) {
    if (start == end) {
        return 1.0;
    }
    AdjList *adj = create(n);
    for (int i = 0; i < edgesSize; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        double prob = succProb[i];
        addEdge(adj, u, v, prob);
        addEdge(adj, v, u, prob);
    }
    MaxHeap heap;
    heap.nodes = (QueueNode *)malloc(n * sizeof(QueueNode));
    heap.idx = 0;
    heap.capacity = n;

    double *res = (double *)calloc((n + 1), sizeof(double));
    res[start] = 1;
    push(&heap, 1.0, start);

    while (heap.idx > 0) {
        QueueNode curr = pop(&heap);
        int u = curr.node;
        double currProb = curr.probability;
        if (u == end) {
            return currProb;
        }
        for (int i = 0; i < adj[u].size; i++) {
            int v = adj[u].edges[i].node;
            double prob = adj[u].edges[i].prob;
            if (currProb * prob > res[v]) {
                res[v] = currProb * prob;
                push(&heap, res[v], v);
            }
        }
    }
    return 0.0;
}


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes) {
    int i, **ans = NULL, *colSizes;
    if (m * n != originalSize) {
        *returnSize = 0;
        return ans;
    }
    ans = (int**) malloc(m * sizeof(int*));
    colSizes = (int*) malloc(m * sizeof(int));
    for (i = 0; i < m; ++i) {
        ans[i] = &original[i*n];
        colSizes[i] = n;
    }
    *returnSize = m;
    *returnColumnSizes = colSizes;
    return ans;
}


int chalkReplacer(int* chalk, int chalkSize, int k) {
    long long tot = 0;
    for (int i = 0; i < chalkSize; ++i)
        tot += chalk[i];

    int complete_rounds = k % tot;
    for (int i = 0; i < chalkSize; ++i) {
        if (complete_rounds < chalk[i])
            return i;
        complete_rounds -= chalk[i];
    }
    return -1;
}




